
	Стабинг, сабы  - Подмена реализации с помощью объекта дублера.
					
					// Есть система классов
						$sender = new Sender();			// у этого класса есть только метод send()  и он организует отправку данных кудато. (Предпложим, что это внешняя не написанная нами система)
						$worker = new Worker($sender);	// Воркер принимает на вход внещнюю систему сендер
						$worker->perform($data);		// Метод перформ делает обработку данных, и внутри вызывает метод send() объекта сендер, чтобы отправить куда-то данные, потом обрабатывает полученный результат и возвращает успех или не успех.
						
	Если мы хотим тестировать нашего $worker то большая часть это обработка локальных данных, но 
	 в своей работе он использует класс сендер (который вообще может быть внешним сервисом написанным не нами.)
	И во время тестирования Workera будет вызываться  Sender  который будет делать какие-то внешние запросы.
	Что в тестах не позволительно. 
	Нужно сделать так, чтобы сендер не мешал, и возвращал фиксированные данные, на которых мы можем сделать кейс.
		Мы исходим из того, что Sender отдельно протестировано и работает правильно.
	Нам нужно делать тестирование Workera изолировано, подменив  Sender.
	
	
						<?php 
						
						namespace Theory;
						
						require_once "Sender.php";
						
						class WorkerTest extends \phpUnit_Framework_TestCase
						{
							private $stub;
							
							public function setUp()
							{
								// Ограничение стабинга на final, private and static methods
								$this->stub = $this->getMockBuilder('Theory\Sender')  			// getMockBuilder  этому методу передаем ия класса, который хотим застабить
												->setMethods(['send'])							// здесь указываем список методов, которые будем стабить
												->getMock();									// теперь генерируем конкретный динамически сформированный объект с застабленными методами
							}
							
							public function testFreshStub()
							{
								$this->asssertEquals(null, $this->stub->send());				// Застабленный метод send() будет возвращать  null
							}
							
							// В случаях если внутри воркера результаты сендера влияют на результаты воркера, то
							// нужно описать дополнительное поведение методу и застабить результат метода сендер
							
							public function testStub()
							{
								// Configure the stub.
								$this->stub->method('send')
										->willReturn(true);
										
								$this->assertTrue($this->stub->send());							// Теперь застабленный метод send() будет возвращать  true
							}
							
							public function testStub2()
							{
								// Configure the stub.
								$this->stub->method('send')
										->will($this->returnArgument(0));						// returnArgument возвращает позиционный аргумент(т.е. описанный метод send() вернет первый полученный на свой вход аргумент
								
								// stub->send('foo') returns 'foo'
								$this->assertEquals('foo', $this->stub->send('foo'));			// Вызываем send с параметром  foo  на выходе  будет  foo 
								
								// stub->send('bar') returns 'bar'
								$this->assertEquals('bar', $this->stub->send('bar'));
							}	
						}


ТЕСТЫ
	Какие методы нельзя застабить в phpuit, используя встроенную функциональность?
		static
		private
		final
	В каких случаях стоит использовать stub?
		Для кода с побочными эффектами
		Для изоляции кода от внешнего сервиса
	

	
ВОПРОСЫ
	Александр АбоимовPRO
	PHP: Автоматическое тестирование → Stub
		Немного не понял один момент. В целом Mock и Stub используются именно для того, чтобы тестировать 
		 наш код без побочных эффектов других сервисов, на которые код может быть завязан. В лекции 
		 упоминается о непозволительности отправки запросов во внешнюю систему из тестов. А как тогда 
		 тестируют наоборот внешние сервисы? Например, что мы получаем корректные данные по API или 
		 сервис отдает корректный XML?
	Александр ВагинPRO
		Внешние сервисы тестируют создатели внешних сервисов :) А вы им доверяете.
		Любой ваш тест на корректность внешнего api покажет только то, что в данный момент оно корректно. 
		 И он не гарантирует того, что через 5 минут его не сломают :)
		С api есть правила хорошего тона - не ломать обратную совместимость, поддерживать документацию и т.д. 
		 Все это позволяет вам безболезненно поддерживать свой код в соответствии с api.
	Александр Абоимов ТСPRO
		Хорошо:) Еще есть более специфичный вопрос. Если смотреть архитектуру MVC. Какое тестирование 
		 используют для контроллеров, в частности для экшенов? В asp.net mvc фреймворке используют юнит 
		 тесты, что как бы логично имхо. Экшн - это ведь функция(метод), а в yii фреймворке для php 
		 говорят использовать функциональные тесты для этого. Это уже совсем другое тестирование через 
		 selenium и т.д. Мне удобен вариант в asp.net, какие тут должны быть правильные мысли на этот счет?
	Александр ВагинPRO
		Тут дело не в удобстве. Юнит тесты стоят дешевле (не зависят от внешнего вида страницы), но 
		 покрывают не весь флоу работы (например, js ошибки вы там не увидите). Поэтому стоит разумно 
		 использовать оба подхода :)
	Kirill MokevninPRO
		Функциональные тесты это не селениум. Все что ходит снаружи и щелкает в браузере по ссылкам 
		 это приемочные тесты.
	Александр Абоимов ТСPRO
		Можно более детально пояснить? Если погуглить на тему "functional testing selenium", есть и 
		 статьи и ответы на эту тематику. https://developer.atlassian.com/docs/faq/writing-your-first-plugin-faq/tips-for-functional-tests-with-selenium 
		 У codeception в доках написано, что функциональные тесты пишутся точно также, как и приемочные. 
		 Еще есть непроверенная информация, что selenium это всего лишь "эмулятор" и на нем можно писать, 
		 как приемочные тесты, так и функциональные.
	Kirill MokevninPRO
		Скажем так, в мире тестирования любыми словами называют любую штуку. Поэтому я лично стараюсь 
		 избегать формулировок на тему "юнит тестирование" и тому подобное, чего и вам советую. 
		 В реальности это просто словоблудие и не влияет ни на что. На практике главное что вы можете 
		 тестировать систему либо вообще снаружи (не из кода, а через браузер например), либо внутри. 
		 Селениум и подобные инструменты это тестирование снаружи, подобных инструментов кучи на всех языках.
	Kirill MokevninPRO
		Кстати функциональным тестированием в веб фреймворках называют тестирование экшенов контроллеров 
		 из кода.
	Александр Абоимов ТСPRO
		Благодарю.Теперь все понял. Согласен с вашей позицией, меньше словоблудия - больше толка :)
		
		
		
ЗАДАНИЕ
	file: TestSolution.php
	Протестируйте, что метод build возвращает true в случае когда он вызван без аргументов и 
	 с аргументом true, который выставляет дебаг режим. 
	 "Застабьте" логгер.

	Пример:

	$logger = new Logger();
	$builder = new Builder($logger);

	$builder->build(); // true
	$builder->build(true); // true
		
		
		
		
									// Мое решение
										<?php

										namespace App;

										require_once "Logger.php";

										class TestSolution extends \PHPUnit_Framework_TestCase
										{
											// BEGIN (write your solution here)
											private $stub;
											private $obj; 
											
											public function setUp()
											{
												$this->stub = $this->getMockBuilder('\App\Logger')
																->setMethods(['info', 'debug'])
																->getMock();
												 
												$this->obj = new Builder($this->stub);
											}
											
											public function testBuild()
											{
												$this->assertTrue($this->obj->build());
												$this->assertTrue($this->obj->build(true));
											}
											// END
										}
		
		
		
									
									// Контрольное решение
										    // BEGIN
											private $builder;

											public function setUp()
											{
												$stub = $this->getMockBuilder('App\LoggerInterface')
													->setMethods(['info', 'debug'])
													->getMock();

												$this->builder = new Builder($stub);
											}

											public function testBuilderWithoutDebug()
											{
												$this->assertTrue($this->builder->build());
											}

											public function testBuilderWithDebug()
											{
												$this->assertTrue($this->builder->build(true));
											}
											// END
		
		
		
		
		
		
		
		
		
		
		
		