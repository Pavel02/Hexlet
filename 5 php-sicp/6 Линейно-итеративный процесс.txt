
	Напишем функцию myPow но уже не рукрсивным процессом, а итеративным.
	Итеративный процесс в общем случае такой процесс, состояние которого можно 
	 описать конечным числом переменных состояний, плюс заранее заданное правило как 
	 эти переменные изменяются, плюс возможно условие при которм процесс закончит работу.
	 
	 
		function myPow($base, $exp) {
			$powIter = function($base, $exp, $acc) use (&$powIter) {		//блочная структура (функция внутри функции)
				if ($exp == 1) { return $acc; }
				return $powIter($base, $exp - 1, $acc * $base);
			};
			
			return $powIter($base, $exp, 1);
		}
		echo myPow(4, 4);
		
		powIter 4, 4, 1
		powIter 4, 3, 4
		powIter 4, 2, 16
		powIter 4, 1, 64
		
	Рекурсивный процесс всегда может быть заменен итеративным
	Рекурсивный процесс, как правило, проще чем итеративный
	
	
ССЫЛКИ
	https://ru.hexlet.io/blog/posts/recursive
	http://ru.stackoverflow.com/questions/4308/Рекурсия-и-итерация
	https://ru.wikipedia.org/wiki/Хвостовая_рекурсия
	
ВОПРОСЫ
Kirill MokevninPRO
	Процесс это то как происходят вычисления, а функция его выражает. Итеративный 
	 процесс может быть построен на рекурсии или без нее (с использованием циклов). 
	 Итеративным его делает можно сказать "несворачиваемость", вычисления в таком процессе 
	 идут в одну сторону. Вычисляется первый шаг, дальше все полученные данные 
	 прокидываются на следующую итерацию, и так до конца. Итеративный процесс 
	 характеризуется наличием аккумулятора, некоей переменной, которая накапливает 
	 результат и возвращается в конце.
	На самом деле, в реальном коде, рекурсией пользуются редко, функции высшего порядка 
	 могут решать почти все задачи. А там где ипользуется рекурсия, то да, чаще всего 
	 приводят к итеративному. Но это скорее удел функциональных языков, в императивных 
	 просто пользуются циклами.
	
	
ЗАДАНИЕ
	Реализуйте рекурсивную функцию factorial используя линейно-итеративный процесс.	
	factorial(3); // 6
	
				// мое решение
				function factorial($num)
				{
					$factorialIter = function($num, $acc) use (&$factorialIter) 
					{
						if ($num == 0) { return $acc; } 
						return $factorialIter($num - 1, $acc * $num);
					};
					
					return $factorialIter($num, 1);
				}				
					
					
				// контрольное решение
				$factorialIter = function ($num, $acc) use (&$factorialIter) {
					if ($num < 2) {
						return $acc;
					}
					return $factorialIter($num - 1, $acc * $num);
				};
				return $factorialIter($num, 1);				
	
	
	
	Реализуйте рекурсивную функцию smallestDivisor используя линейно-итеративный процесс. 
	 Функция должна находить минимальный делитель переданного числа.
	Минимальный делитель числа - это наименьшее число, на которое делится исходное без остатка.
	smallestDivisor(9); // 3
	smallestDivisor(17); // 17
	Алгоритм
	Для поиска этого числа достаточно последовательно проверять делимость начиная с двойки. 
	 Если делитель не найден, значит это само число, а искомое число простое.
	Подсказки
	Остаток от деления: 5 % 3
	
					// мое решение
					function smallestDivisor($num)
					{
						$divisorIter = function($num, $acc) use (&$divisorIter)
						{
							if ($acc > $num/2) {
								return $num;
							} elseif ($num % $acc == 0) {
								return $acc;
							} else {
								return $divisorIter($num, ++$acc);
							}
						};

						return $divisorIter($num, 2);
					}					
	
	
					// контрольное решение для примера
					$iter = function ($acc) use ($num, &$iter) {
						if ($num <= $acc) {
							return $num;
						}
						if ($num % $acc == 0) {
							return $acc;
						}
						return $iter($acc + 1);
					};
					return $iter(2);
	
	
	
	
	
	
	