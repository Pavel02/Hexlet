
	Функция это абстракция над составными операциями.
	Если бы мы на вход могли принимать аргументы только числа, то 
	 нам бы пришлось делать множество таких одинаковых функций, которые 
	 по сути имеют один шаблон выполнения.
	 
			$sumIntegers = function($a, $b) use (&$sumIntegers){
				if ($a > $b) { return 0; }
				return $a + $sumIntegers($a + 1, $b);
			};
		
			$sumCubes = function($a, $b) use (&$sumCubes){
				if ($a > $b) { return 0; }
				return ($a * $a * $a) + $sumCubes($a + 1, $b);
			};
		
		// Функции разные а идея одинаковая.
	
	Функции высшего порядка можно передавать как аргументы.
			// Функция ниже суммирует от $a до $b, применяя доп функцию.
			function sum($a, $b, $func) {				// На вход будем принимать функцию, которая будет определять то, что мы складываем, какую последовательность мы складываем 				
				if ($a > $b) { return 0; }
				return $func($a) + $sum($a + 1, $b, $func);
			}
	
			echo sum(1, 5, function($x) {return $x;});			// Сумма чисел от и до	
			echo sum(1, 5, function($x) {return $x * $x;});		// Сумма чисел от и до	
			
			// Можем вынести в отдельную функцию и это будет более универсально
			$identity = function($x) { return $x * $x * $x; };
			
			echo sum(1, 5, $identity);							// Сумма кубов
			
			
		
	
ВОПРОСЫ
Александр О.PRO
Добрый день, Александр!

пока мы не стали использовать функцию $func(), которую перед этим нигде не объявили

Давайте отталкиваться от исходного кода:

# Определение функции sum (формальные параметры)
function sum($a, $b, $func) {
 if ($a > $b) { return 0; }
 return $func($a) + sum($a + 1, $b, $func);
}

# Вызов функции sum (фактические параметры)
sum(1, 5, function($x) { return $x * $x; });
Обратите внимание, что самым первым идёт определение функции sum (Вы ведь уже крепко 
 различаете определение функции от её вызова, да?!). $a, $b, $func здесь являются 
 формальными параметрами - они не содержат никаких значений, это имена локальных переменных, 
 к которым можно обращаться в теле функций (в эти переменные будут записываться значения 
 фактических параметров (аргументов), передаваемых в функцию при её вызове).

Как она, вообще исходя из чего она определяет, какую операцию мы выполняем?

При вызове sum в формальный параметр $func и передаётся конкретная функция, 
 которая будет определять, какую операцию производить с числами.

# хотим получить сумму квадратов - передаём соответствующую функцию
sum(1, 5, function($x) { return $x * $x; });

# хотим получить сумму кубов - передаём соответствующую функцию
sum(1, 5, function($x) { return $x * $x * $x; });

# хотим получить, например, суммy исходных чисел, увеличенных на единицу
sum(1, 5, function($x) { return $x + 1; });
Пересмотрел прошлые видео, с 2 вопросом понял

Циклы - это итеративный процесс в императивном стиле (происходит изменение состояния). 
 В уроках же чаще демонстрируется функциональный подход. Ознакомьтесь со вспомогательным 
 материалом Рекурсия, рекурсивный процесс и итеративный процесс https://ru.hexlet.io/blog/posts/recursive

	
	
	
	
ЗАДАНИЕ
	Реализуйте функцию sum из видео, используя итеративный процесс.
	
				// мое решение
					
					
				// контрольное решение
				function sum($start, $finish, $func)
				{
					$iter = function ($current, $acc) use ($finish, $func, &$iter) {
						if ($current > $finish) {
							return $acc;
						}

						return $iter($current + 1, $acc + $func($current));
					};

					return $iter($start, 0);	
				}
	
	
	
	Реализуйте функцию product, которая сворачивает последовательность с помощью переданной функции. 
	 Последовательность задается первыми двумя аргументами. Первый это начало последовательности, 
	 второй это окончание. Например, последовательность [1, 4] это 1, 2, 3, 4. Свертка это сведение 
	 последовательности к какому-то значению. Само значение зависит от того, какая операция применяется 
	 при свертке. Обратите внимание, что последовательность, типа [$x, $x], состоит из одного числа $x и 
	 свертке не подлежит, функция в этом случае должна вернуть само число $x.

	'С помощью переданной функции' означает то, что мы применяем эту функцию к элементам последовательности и 
	 используем ее результат, как аккумулятор (накопитель результата).

	Примеры:

	// f(1, 2) => 1 + 2
	3 == product(1, 2, function ($first, $second) { return $first + $second; }) // sum

	// f(f(3, 4), 5) => f(-1, 5) => -1 - 5
	-6 == product(3, 5, function ($first, $second) { return $first - $second; }) // minus
	По последнему примеру видно, что операция является левоассоциативной. Рассмотрим данное свойство 
	 подробнее на последовательности [1, 4]:

	Последовательность: 1, 2, 3, 4. Операция: f - внутренности не важны, главное, что это некая функция.

	Разложим операцию с учетом ее левоассоциативности:

	f($left1, $right1); // $right1 = 4
	f(f($left2, $right2), $right1); // $right2 = 3
	f(f(f($left3, $right3), $right2), $right1); // $right3 = 2

	// f = function ($first, $second) { return $first - $second; };
	f(f(f(1, 2), 3), 4);
	f(f(-1, 3), 4);
	f(-4, 4); // -8
	
					// мое решение
		
	
					// контрольное решение для примера
					function product($num1, $num2, $func)
					{	
						if ($num1 == $num2) {
							return $num2;
						}
						return $func(product($num1, $num2 - 1, $func), $num2);	
					}
	
	
	