
	В интерфейсе есть определение функций, но нет реализаций.
	Интерфейс задает контракт (то что ожидается).
					// файл RendererInterface.php
					
					namespace Theory\Renderers;
					
					interface RendererInterface
					{
						public function render($text);
					}
	
	 Далее мы используем интерфейс в другом файле
					// файл HTML.php
					
					namespace Theory\Renderers;
					
					require_once "RendererInterface.php";
					
					class HTML implements RenderInterface
					{
						public function render($text)		// Определение функции должно полностью совпадать с Интерфейсом
						{
							return "html";
						}
					}

	Большинство динамических язаков не обладает отдельной структурой внутри языка как Интерфейс.
	т.е. не в Питоне не в Руби такого нет.
	
	В принципе если нет интерфейса, то он все равно неявно реализуется, так как в дальнейшем коде 
	 все таки ожидается наличие определенных функций.
	Ставите вы интерфейсы или нет, РНР ЯП динамический и ошибку вы получите только во время 
	 исполнения кода, и если у вас нет тестов, то такое может произойти только на продакшене.
	
	Имплементить можно несколько Интерфейсов, а внутри интерфейса можем обозначить конструктор
					interface MarkdownInterface
					{
						public function __construct(RenderInterface $renderer);
					}
	
	
ВОПРОСЫ
	Damir NPRO

		Мне кажется, что данный урок немного сложен для понимания и очень плохо объясняет суть. 
		 Используется хоть и более практический, но сложный пример. При этом не раскрывается 
		 суть и полезность интерфейсов. Просто рассказали, что такая структура существует, быстрый 
		 и непонятный пример, как это может выглядеть в коде, а затем половина времени ушла на рассказ 
		 о недостатках и о том, что на самом то деле это не так уж и нужно. Извиняюсь, но данная 
		 лекция больше запутала меня, нежели дала мне правильное представление об интерфейсах. 
		 Статьи в интернете же помогли расставить всё по местам.
		Я считаю, что интерфейсы на самом деле гораздо более важны, нежели они описываются у вас в 
		этом уроке. Нужно сделать упор на то, что интерфейс предназначен для создания того самого 
		уровня абстракции, тем самым отделяя её от реализации (что очень важно для ООП). А дальше уже 
		на то, что это может быть очень полезно. Например, что мы можем применять разные реализации 
		интерфейсов в зависимости от задачи. Взять ту же сортировку. Использовать отсортированный 
		массив либо связный список в зависимости от того, как мы будем использовать нашу структуру данных. 
		Во-первых, это более наглядный пример. Во-вторых, дошедшие до данного урока люди уже точно 
		знакомы с данными понятиями, нежели с рендерами, маркдаунами, xml и сутью примера в видео. 
		Также, он более легкий для понимания.

	Alexander Alexandryan
		Много писать об ужасе этого урока не буду, только подчеркну самое главное, 
		 вы так и не раскрыли сути интерфейсов в php, точнее их практическое использование. 
		 Так вот интерфейсы удобно использовать в команде, когда есть опытный teamlead который 
		 может набрасать интерфейс и дать реализацию новичку, в классе будут реализованы 
		 хотя бы минимальные методы..
	Artem
		Не так сложно было решить, как понять, чего от меня хотят. Уже хотел сдаться и 
		 подсмотреть решения учителя, но решил еще подумать и все таки, волшебный образом додумался :)
		Только вот мне не ясна одна строчка в интерфейсе "IteratorAggregate":
			return new \ArrayIterator($this->items);
		Здесь непонятно это - "\ArrayIterator", откуда мы это берем, и зачем слеш? Еще было не до конца 
		 ясно, как это все работает, но пока это писал - дошло.
	Александр ПавловPRO
		IteratorAggregate это объект SPL, который идет вместе с PHP - 
		 http://php.net/manual/ru/class.iteratoraggregate.php
		Слеш спереди указывает на то, что этот объект из базового пространства имен - 
		 http://php.net/manual/ru/language.namespaces.php

		 
		 
ССЫЛКИ
	http://php.net/manual/en/language.oop5.interfaces.php
	http://php.net/manual/ru/language.oop5.interfaces.php
	
	
ТЕСТЫ
	Если класс это завод, то интерфейс это
		Схемы и спецификации, по которым работает завод
	
	Класс может реализовывать (implements) несколько интерфейсов
	
	Можно ли интерфейсы распределять по областям видимости (namespace'ам) аналогично классам?
		Да.


ЗАДАНИЕ
	В PHP есть множество встроенных интерфейсов. Они позволяют добавить в класс дополнительные 
	 возможности. Примерами таких интерфейсов являются Countable и IteratorAggregate.

	Чтобы реализовать интерфейс Countable, нужно в класе определить метод count. Тогда объекты 
	 этого класса можно передавать в качестве аргумента функции count и sizeof.

	Пример использования интерфейса Countable:

		namespace App;

		class SomeClass implements \Countable
		{
		  public function count()
		  {
			return 10;
		  }
		}

		$object = new SomeClass();

		count($object); // 10
	
	Объект, реализовавший IteratorAggregate, может быть использован в цикле foreach. Для этого 
	 необходимо определить метод getIterator и вернуть в нем внутренний итератор.

	Пример использования интерфейса IteratorAggregate:

		namespace App;

		class MyClass implements \IteratorAggregate
		{
		  private $innerArray = ['foo', 'bar', 'baz'];

		  public function getIterator()
		  {
			return new \ArrayIterator($this->innerArray);
		  }
		}

		$object = new MyClass();

		foreach ($object as $value) {
		  echo $value;
		}
		// foobarbaz
		
	Cart.php
	Реализуйте в классе Cart методы, определенные в интерфейсах \Countable и \IteratorAggregate. 
	 Метод count() должен возвращать число товаров в корзине. Кроме того, если передать объект корзины в 
	 конструкцию foreach, то должны перечислиться все товары, находящиеся в ней.

	Пример использования:

		use Shop\Cart;

		$cart = new Cart();

		$cart->add(new Item(1, "milk", 5))
		$cart->add(new Item(2, "water", 2));

		// Вызов функции `count` или `sizeof` на объекте корзины должен вернуть количество товаров в ней
		count($cart); // 2

		// При использовании корзины в `foreach` должны перечисляться товары в корзине
		foreach ($cart as $item) {
		  echo "id: " . $item->id . ", name: " . $item->name . ", price: " . $item->price . PHP_EOL;
		}
		// id: 1, name: milk, price: 5
		// id: 2, name: water, price: 2

		$cart->remove(2);

		count($cart); // 1

		$cart->clear();

		count($cart); // 0
			 
	
	
						// мое решение и контрольное решение совпадает
						  // BEGIN
						  public function count()
						  {
							return count($this->items);
						  }

						  public function getIterator()
						  {
							return new \ArrayIterator($this->items);
						  }
						  // END
					