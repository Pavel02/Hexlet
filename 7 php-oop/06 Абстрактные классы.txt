	PHP 5 поддерживает определение абстрактных классов и методов. Класс, который содержит по крайней мере один 
	 абстрактный метод, должен быть определен как абстрактный. Следует помнить, что нельзя создать экземпляр 
	 абстрактного класса. Методы, объявленные абстрактными, несут, по существу, лишь описательный смысл и не могут включать реализации.
	
	
	Как может выглядеть простая система кеширования
				interface CacheInterface
				{
					public function __construct($options);		// конструктор принимает опции в которых возможно будут параметры соединения (время жизни кеша и т.д.)
					public function get($key);					// Получаем по какому-то ключу, значение
					public function set($key, $value); 			// Устанавливаем по какому-то ключу, какое-то значение
				}
				
				// $cache = new DbCache($options);
				// $cache->set("user", 3);
				// 3 == $cache->get("user");		// проверяем что есть значение по ключу (учитывая, что это кеш, то через некоторое время его уже может не быть)
				
				
				abstract class Cache implements CacheInterface
				{
					protected $options;
					
					public function __construct($options)
					{
						$this->options = $options;
						$this->connect();					// здесь  connect  это закрытая не публичная функция
					}
					
					abstract protected function connect();		// наследники должны будут реалиовать этот метод 
				}
				
				
				class DbCache extends Cache
				{
					public function get($key)
					{
						return $this->connection->get($key);
					}
					
					public function set($key, $value)
					{
						return $this->connection->set($key, $value);
					}
					
					private function connect()
					{
						......										// Здесь должна быть реализация приватного метода
					}
					
				}
				
				
	В абстрактном классе есть абстрактные методы, чью реализацию мы передаем подклассам
	Человек должен завязываться на интерфейсы. (но абстрактные классы дают возможность через них)
				
	С абстрактными классами в php есть одна интересная особенность. Если этот класс реализует (не полностью) интерфейс, 
	 то определения методов из интерфейса становятся абстрактными методами в этом классе.	
	
	 
ТЕСТЫ
	Абстрактные классы это способ разделить общий код между наследниками
	Нельзя создавать экзепляры абстракного класса
	Абстрактный класс может не содержать абстрактных методов
	Абстрактный класс может наследоваться от абстрактного класса
	
	
ССЫЛКИ
	http://php.net/manual/ru/language.oop5.abstract.php
	
ВОПРОСЫ
	Алексей Владимирович ТСPRO
		Меня останавливает то, что FastMailer содержит только 1 метод. Например, 
		 когда вы расширяете класс, дочерний класс наследует все публичные и защищенные 
		 методы из родительского класса. До тех пор пока не будут эти методы переопределены, 
		 они будут сохранять свою исходную функциональность. То есть FastMailer 
		 унаследует оба метода, но они не прописаны в его теле просто?
	Аркадий МещеряковPRO
		Да, их не нужно прописывать, подтянутся автоматом из предка и потомок 
		 сможет ими пользоваться. Все кроме тех, что помечены private.

	Kirill Kikimov
		Ну как я понимаю все верно. Интерфейс ни чего не реализует, а абстрактный 
		 класс реализует только общие для всех потомков методы. Таким образом можно 
		 написать на пример много разных вариантов рендеров, в которых надо будет 
		 реализовывать только метод Render. Если бы не было абстрактного класса, 
		 пришлось бы в каждом рендере реализовывать гетеры, сеттеры и конструктор.
	

ЗАДАНИЕ 
	Реализуйте абстрактный класс Mailer согласно интерфейсу MailerInterface. 
	 Реализуйте в нем методы setVar (для сохранения пары "ключ-значение") и getAllVars 
	 (для получения массива всех сохраненных пар).
	
	Абстрактные классы позволяют написать частичную реализацию, которая будет дополнена или 
	 завершена наследниками. В данном примере нужно реализовать указанный интерфейс, в него 
	 входят работа с данными и базовый рендеринг.
	Собственно наследуемый класс никак не вмешивается в работу с данными, а 
	 просто пользуется готовыми методами. Написать такой класс проще, код абстрактного 
	 класса можно переиспользовать, а сохраняя интерфейс можно менять внутреннее устройство 
	 не изменяя код наследников. 
	С данными все довольно просто - их нужно запоминать и отдавать. А рендеринг - только 
	 слово страшное, на самом деле он реализован в потомке, а в абстрактном вполне подходит 
	 абстрактный метод (который потомок будет обязан реализовать), как Вы и сделали. :)
	 
					// мое решение совпадает с контрольным
						// файл MailerInterface
							<?php

							namespace App;

							interface MailerInterface
							{
								public function setVar($key, $value);
								public function getAllVars();
								public function render();
							}
						

						
						// файл Mailer.php
							<?php

							namespace App;

							// BEGIN (write your solution here)
								abstract class Mailer implements MailerInterface
								{   
									protected $vars = [];
									
									public function setVar($key, $value)
									{
										$this->vars[$key] = $value;
									}
									
									public function getAllVars()
									{
										return $this->vars;
									}
									
									abstract public function render();
								}
							// END
						
						
						//файл FastMailer
							<?php

							namespace App;

							class FastMailer extends Mailer
							{
								public function render()
								{
									$data = json_encode($this->getAllVars());
									return "<html>{$data}</html>";
								}
							}


	 