	
	Ключевое слово finally это механизм позволяющий совершать какое-то действие независимо от того 
	 было исключение или нет.
	 
					$handle = fopen($fileparth, "r");	// У нас есть обычный процедурный способ чтения из файла
														// функция  fopen  возвращает нам файловый дескриптор, для того чтобы работать с этим файлом далее.
					try {
						$data = fread($handle, filesize($fileparth));
						// NOTE  to do something
					} finally {
						fclose($handler);				// Всегда когда выполнится блок try и не важно как (ннормально отработает или возникнет исключением), то отработает блок  finally и закроет ресурс.
					}
				
	Есть понятие ресурса - это сокеты, это файлы, это соединение с БД, все эти ресурсы небесконечны и 
	мы должны их чисть.
	 
	
ТЕСТЫ
	В каких случаях выполняется блок finally
		Выполняется в любом случае, независимо от того было исключение или нет.
		
	Сколько блоков finally можно определять для одного try?
		1
	
	Можно ли бросать исключение из блока finally?
		Да
		
		
		
ЗАДАНИЕ 
	FileReader - это небольшая абстракция, представляющая собой интерфейс для чтения файла.

			namespace App\FileReader;

			interface FileReader
			{
				public function read();
				public function close();
			}
	Поведение у FileReader следующее. Вызов метода read() возвращает содержимое файла, связанного с данным 
	 объектом FileReader. Если в процессе чтения файла возникает ошибка, то будет брошено исключение FileReaderException. 
	 Так как FileReader использует ресурсы системы, после чтетия файла, его необходимо закрыть. Не зависимо от того 
	 была ошибка при чтении или нет. Для этого у FileReader нужно вызвать метод close().

	Solution.php
	 Допишите функцию read. Она должна читать данные из $fileReader->read() и вызывать соответствующие функции 
	 с результатом чтения: в случае если, данные из FileReader прочитаны успешно, она должна вызывать $onSuccess, 
	 передав данные в качестве аргумента, а в случае если при чтении возникла ошибка FileReaderException, функция 
	 должна вызвать $onError, передав исключение в качестве аргумента. При этом $fileReader после чтения должен 
	 быть закрыт и в случае успеха и в случае ошибки.
	
	
							// мое решение  (см. Exercise11)
								try {
									$data = $fileReader->read();
									$onSuccess($data);
								} catch (FileReaderException $e) {
									$onError($e);
								} finally {
									$fileReader->close();
								}							
	
	
	
							// контрольное решение
								  try {
									$content = $fileReader->read();
									$onSuccess($content);
								  } catch (FileReaderException $exception) {
									$onError($exception);
								  } finally {
									$fileReader->close();
								  }
	
	
	
	
	