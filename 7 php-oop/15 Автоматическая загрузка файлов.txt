
	Если Ваш проект содержит достаточно много файлов, то может быть утомительно постоянно 
	 набирать require  и описывать все необходимые файлы для включения.
	 
	Большинство разработчиков объектно-ориентированных приложений используют такое соглашение именования 
	 файлов, в котором каждый класс хранится в отдельно созданном для него файле.
	 Каждая папка соответствует   неймспейсу  , дальше название класса  становится названием для файла с маленькой буквы.
	 
	Наличие namespace  никак не помогает это просто структуризация кода на уровне самого кода, но 
	 не на уровне файловой системы.
	 
	__autoload()  магическая функция которая вызывается всегда, когда идет 
	 попытка "инстанцировать" объект како-то класа.
	 
	__autoload  уже никто не использует. в РНР есть стандартная библиотека  SPL.
	
	
				<?php
				
				namespace Theory;
				
				spl_autoload_register(function($class) {
					$parth = dirname(__FILE__) . "/" . strtolower(str_replace("\\", "/", $class));
					spl_autoload($parth);
				});
	 
				$app = new \ns\Application();
				
				
	spl_autoload_register  эта функция на вход принимает лямбду в которой единственный параметр это имя класса.
	strtolower()  все символы маленькие.
	spl_autoload($parth); 		не надо добавлять .php    функция делает это за нас.

	__DIR__  путь до файла. Аналогично dirname(__FILE__)  (__FILE__ путь жл текущ файла,  dirname оставляет директорию).
	
	 
		
	Если мы соблюдаем именование классов, что неймспейс соответсвует папочке а дальше файл с названием класса, то будет работать следующий вариант:
				spl_autoload_extensions(".php");
				spl_autoload_register();
				
				
	
ССЫЛКИ
	http://php.net/manual/en/function.spl-autoload.php
	http://php.net/manual/ru/function.spl-autoload.php
	http://php.net/manual/en/language.oop5.autoload.php
	http://php.net/manual/ru/language.oop5.autoload.php
	
	
ТЕСТЫ
	Можно ли обойтись без автоматической загрузки классов?
		да
	
	Что можно использовать вместо autoload?
		require
	
	Возможно ли использование автоматической загрузки классов в проекте, в котором отсутствует деление на пространства имен?
		конечно да
ВОПРОСЫ
	Сергей ПопковPRO
		Скажите, пожалуйста, откуда в берётся значение переменной $class в анонимной функции?
	Kirill GrafovPRO
		Оно туда передается при вызове в качестве аргумента.
	
	
	Eugene Komissarov
		На сколько я понял **spl_autoload **будет работать только если имена папок и файлов в 
		 реальности имеют нижний регистр...
	Григорий Грудинин ТСPRO
		Я специально сделал два отдельных файла: с классом и обращением к классу. Так в итоге 
		 они работали только тогда, когда весь путь к файлу был в реальности в нижнем регистре. 
		 strtolower никак не помогала, более того, если записать имя класса и пространство имен 
		 в верхнем регистре, то $path = /.../Classes/Application, т.е. аргумент spl_autoload в 
		 верхнем регистре, и всё работает... Может я что-то не понял, но в php.net написано, 
		 что аргументом идёт: "имя класса (и пространства имен) в нижнем регистре, описание которого 
		 требуется загрузить".
	Дмитрий СтарцевPRO
		spl_autoload принимает имя класса и строит из него путь к файлу, приводя все в нижний 
		 регистр require_once принимает путь к файлу как есть
	Григорий Грудинин ТСPRO
		Я не понял в итоге, почему, если в пути одна из папок в верхнем регистре Documents, то 
		 даже с strtolower не работает, если spl_autoload приводит в нижний регистр?
	Дмитрий СтарцевPRO
		Потому что файловая система чувствительна к регитру. Он ищет папку documents и не находит. 
		 strtolower ни на что не влияет, потому что внутри spl_autoload она и так вызывается
	
	
ЗАДАНИЕ
	file: test.php
	Зарегистрируйте автозагрузчик классов, так чтобы тесты прошли.
	
						// мое решение 
						// файл Test.php
							<?php

							namespace App;

							// BEGIN (write your solution here)
							spl_autoload_register(function($class) {
								$parth = __DIR__ . "/" . str_replace("\\", "/", $class) . ".php";
								require_once $parth;
							});
							// END

							class Test extends \PHPUnit_Framework_TestCase
							{
								public function testClasses()
								{
									$router = new \Framework\Router();
									$this->assertInstanceOf('Framework\Router', $router);

									$controller = new \Framework\Controller\Base();
									$this->assertInstanceOf('Framework\Controller\Base', $controller);
								}
							}
						
	
	
	
	
	
	